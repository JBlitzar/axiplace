<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Axiplace | JBlitzar</title>
    <link rel="stylesheet" href="https://jblitzar.github.io/global.css" />
    <link rel=icon href=https://jblitzar.github.io/favicon.png> '
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <style>
      canvas {
        border: 1px solid #ccc;
        cursor: crosshair;
        display: block;
        margin: 0 auto;
      }

      #stream-container {
        position: relative;
        display: inline-block;
        width: 100%;
        min-width: 600px;
      }

      #stream {
        display: block;
        width: 100%;
        height: auto;
      }

      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: all;
        cursor: crosshair;
        z-index: 300;
      }

      /* Mobile: crop to show only the grid area */
      @media (max-width: 599px) {
        #stream-container {
          min-width: unset;
          overflow: hidden;
        }
      }
    </style>
  </head>
  <body>
    <h1>Thing</h1>
    <br />
    <center>
      <div id="stream-container">
        <img id="stream" src="" alt="Loading stream..." />
        <canvas id="canvas"></canvas>
      </div>

      <div id="editor-modal" style="display: none">
        <h3>Draw Curve for Cell (<span id="cell-coords"></span>)</h3>
        <canvas id="editor-canvas" width="400" height="400"></canvas>
        <br />
        <button id="submit-curve">Submit</button>
      </div>
    </center>

    <script>
      const API_BASE = "https://axiplace.vercel.app";

      async function loadStreamUrl() {
        try {
          const resp = await fetch(`${API_BASE}/stream-url`);
          const data = await resp.json();
          if (data.stream_url) {
            document.getElementById("stream").src = data.stream_url;
            resizeCanvas();
          } else {
            console.error("No stream URL available:", data.error);
          }
        } catch (err) {
          console.error("Failed to fetch stream URL:", err);
        }
      }

      loadStreamUrl();
    </script>

    <script>
      let GRID_W = 22;
      let GRID_H = 17;

      const GRID_CONFIG = {
        offsetX: 0.18,
        offsetY: 0.05,

        width: 0.46,
        height: 1,
      };

      const streamContainer = document.getElementById("stream-container");
      const stream = document.getElementById("stream");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      let CELL_SIZE = 0;
      let GRID_OFFSET_X = 0;
      let GRID_OFFSET_Y = 0;
      let GRID_WIDTH_PX = 0;
      let GRID_HEIGHT_PX = 0;

      function Cell(x, y) {
        this.x = x;
        this.y = y;
        this.selected = false;
      }
      window._redrawCells = function () {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (const cell of grid) {
          cell.draw(ctx);
        }
      };
      Cell.prototype.isInside = function (mx, my) {
        const cellX = GRID_OFFSET_X + this.x * CELL_SIZE;
        const cellY = GRID_OFFSET_Y + this.y * CELL_SIZE;
        return (
          mx >= cellX &&
          mx < cellX + CELL_SIZE &&
          my >= cellY &&
          my < cellY + CELL_SIZE
        );
      };
      Cell.prototype.draw = function (ctx) {
        const cellX = GRID_OFFSET_X + this.x * CELL_SIZE;
        const cellY = GRID_OFFSET_Y + this.y * CELL_SIZE;

        ctx.strokeStyle = "#ccc";
        ctx.strokeRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
        if (this.selected) {
          ctx.fillStyle = "rgba(0, 0, 255, 0.3)";
          ctx.fillRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
        }
      };
      Cell.prototype.setSelected = function (grid) {
        for (const cell of grid) {
          cell.selected = false;
        }
        this.selected = true;
        window._redrawCells();
      };
      const grid = [];
      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
          grid.push(new Cell(x, y));
        }
      }
      window._cell = grid[0];

      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        for (const cell of grid) {
          if (cell.isInside(mx, my)) {
            openEditorModal(cell);
            cell.setSelected(grid);
            window._cell = cell;
            window._redrawCells();
            break;
          }
        }
      });

      function BezierPoint(x, y, movingCallback = null, edgesOnly = false) {
        this.x = x;
        this.y = y;
        this._inst = new fabric.Circle({
          radius: 10,
          fill: "red",
          left: x,
          top: y,
          hasControls: false,
          hasBorders: false,
          selectable: true,
          lockRotation: true,
          lockScalingX: true,
          lockScalingY: true,
        });
        this.edgesOnly = edgesOnly;

        function _clamp(value, min, max) {
          return Math.min(Math.max(value, min), max);
        }

        this._inst.on("moving", (e) => {
          const canvasWidth = this._inst.canvas.width;
          const canvasHeight = this._inst.canvas.height;
          const radius = this._inst.radius;

          this._inst.left = _clamp(
            this._inst.left,
            radius,
            canvasWidth - radius
          );
          this._inst.top = _clamp(
            this._inst.top,
            radius,
            canvasHeight - radius
          );

          if (this.edgesOnly) {
            let xPass =
              this._inst.left > canvasWidth - radius ||
              this._inst.left < radius;
            let yPass =
              this._inst.top > canvasHeight - radius || this._inst.top < radius;

            // both pass == corner, one pass == edge
            // no pass == violation! Go to closest edge
            if (!xPass && !yPass) {
              // ugh violates DRY but whatever
              let dl = this._inst.left - radius;
              let dr = canvasWidth - radius - this._inst.left;
              let dt = this._inst.top - radius;
              let db = canvasHeight - radius - this._inst.top;
              let minDist = Math.min(dl, dr, dt, db);
              if (minDist === dl) {
                this._inst.left = radius;
              } else if (minDist === dr) {
                this._inst.left = canvasWidth - radius;
              } else if (minDist === dt) {
                this._inst.top = radius;
              } else if (minDist === db) {
                this._inst.top = canvasHeight - radius;
              }
            }
          }

          this.x = this._inst.left;
          this.y = this._inst.top;
          //   console.log(this._inst);
          if (movingCallback) movingCallback();
        });
      }
      document.getElementById("submit-curve").addEventListener("click", () => {
        fetch(`${API_BASE}/add_command`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ command: curCurve }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.status === "success") {
              alert("Curve submitted successfully!");
              document.getElementById("editor-modal").style.display = "none";
              for (const cell of grid) {
                cell.selected = false;
              }
            } else {
              alert(data.message || data.error || "Failed to submit curve");
            }
          })
          .catch((err) => {
            console.error("Error submitting curve:", err);
            alert("Failed to submit curve");
          });
      });
      let curCurve = null;
      function moved() {
        console.log(bezierPath);
        const pathData = [
          ["M", p0._inst.left, p0._inst.top],
          [
            "C",
            p1._inst.left,
            p1._inst.top,
            p2._inst.left,
            p2._inst.top,
            p3._inst.left,
            p3._inst.top,
          ],
        ];

        bezierPath.set({ path: pathData });
        console.log(bezierPath);
        mcanvas.renderAll();
        curCurve = {
          cell: [GRID_W - window._cell.x - 1, GRID_H - window._cell.y - 1],
          path: [
            [1 - p0.x / mcanvas.width, 1 - p0.y / mcanvas.height],
            [1 - p1.x / mcanvas.width, 1 - p1.y / mcanvas.height],
            [1 - p2.x / mcanvas.width, 1 - p2.y / mcanvas.height],
            [1 - p3.x / mcanvas.width, 1 - p3.y / mcanvas.height],
          ],
        };
      }
      const mcanvas = new fabric.Canvas("editor-canvas");
      const p0 = new BezierPoint(50, 390, moved, true);
      const p1 = new BezierPoint(150, 50, moved);
      const p2 = new BezierPoint(250, 50, moved);
      const p3 = new BezierPoint(350, 390, moved, true);
      mcanvas.add(p0._inst, p1._inst, p2._inst, p3._inst);
      let bezierPath = new fabric.Path(
        `M ${p0._inst.left} ${p0._inst.top} C ${p1._inst.left} ${p1._inst.top}, ${p2._inst.left} ${p2._inst.top}, ${p3._inst.left} ${p3._inst.top}`,
        {
          fill: "",
          stroke: "black",
          strokeWidth: 2,
          selectable: false,
          objectCaching: false,
        }
      );
      curCurve = {
        cell: [GRID_W - window._cell.x - 1, GRID_H - window._cell.y - 1],
        path: [
          [1 - p0.x / mcanvas.width, 1 - p0.y / mcanvas.height],
          [1 - p1.x / mcanvas.width, 1 - p1.y / mcanvas.height],
          [1 - p2.x / mcanvas.width, 1 - p2.y / mcanvas.height],
          [1 - p3.x / mcanvas.width, 1 - p3.y / mcanvas.height],
        ],
      };
      mcanvas.add(bezierPath);
      function openEditorModal(cell) {
        window._cell = cell;
        const modal = document.getElementById("editor-modal");

        document.getElementById(
          "cell-coords"
        ).innerText = `${cell.x}, ${cell.y}`;
        modal.style.display = "block";
        modal.scrollIntoView({ behavior: "smooth", block: "center" });
        moved();
      }

      function resizeCanvas() {
        const isMobile = window.innerWidth < 600;

        if (isMobile && stream.naturalWidth > 0) {
          // Mobile: crop to show only the grid area
          // Used AI to code this block because I'm lazy and weird math + css is hard
          const containerWidth = streamContainer.offsetWidth;

          const scaledImageWidth = containerWidth / GRID_CONFIG.width;
          const scale = scaledImageWidth / stream.naturalWidth;
          const scaledImageHeight = stream.naturalHeight * scale;

          const offsetX = -scaledImageWidth * GRID_CONFIG.offsetX;
          const offsetY = -scaledImageHeight * GRID_CONFIG.offsetY;

          const gridHeightPx = scaledImageHeight * GRID_CONFIG.height;

          streamContainer.style.height = gridHeightPx + "px";

          stream.style.width = scaledImageWidth + "px";
          stream.style.height = scaledImageHeight + "px";
          stream.style.position = "relative";
          stream.style.left = offsetX + "px";
          stream.style.top = offsetY + "px";

          canvas.width = containerWidth;
          canvas.height = gridHeightPx;
          canvas.style.width = containerWidth + "px";
          canvas.style.height = gridHeightPx + "px";
          canvas.style.left = "0";
          canvas.style.top = "0";

          GRID_OFFSET_X = 0;
          GRID_OFFSET_Y = 0;
          GRID_WIDTH_PX = containerWidth;
          GRID_HEIGHT_PX = gridHeightPx;
        } else {
          stream.style.width = "100%";
          stream.style.height = "auto";
          stream.style.position = "";
          stream.style.left = "";
          stream.style.top = "";
          streamContainer.style.height = "";
          canvas.style.width = "";
          canvas.style.height = "";
          canvas.style.left = "";
          canvas.style.top = "";

          const rect = stream.getBoundingClientRect();

          canvas.width = rect.width;
          canvas.height = rect.height;

          GRID_OFFSET_X = rect.width * GRID_CONFIG.offsetX;
          GRID_OFFSET_Y = rect.height * GRID_CONFIG.offsetY;
          GRID_WIDTH_PX = rect.width * GRID_CONFIG.width;
          GRID_HEIGHT_PX = rect.height * GRID_CONFIG.height;
        }

        CELL_SIZE = Math.min(GRID_WIDTH_PX / GRID_W, GRID_HEIGHT_PX / GRID_H);

        window._redrawCells();
      }

      stream.addEventListener("load", resizeCanvas);
      window.addEventListener("resize", resizeCanvas);

      resizeCanvas();
    </script>
    <script>
      !(function (t, e) {
        var o, n, p, r;
        e.__SV ||
          (window.posthog && window.posthog.__loaded) ||
          ((window.posthog = e),
          (e._i = []),
          (e.init = function (i, s, a) {
            function g(t, e) {
              var o = e.split(".");
              2 == o.length && ((t = t[o[0]]), (e = o[1])),
                (t[e] = function () {
                  t.push([e].concat(Array.prototype.slice.call(arguments, 0)));
                });
            }
            ((p = t.createElement("script")).type = "text/javascript"),
              (p.crossOrigin = "anonymous"),
              (p.async = !0),
              (p.src =
                s.api_host.replace(".i.posthog.com", "-assets.i.posthog.com") +
                "/static/array.js"),
              (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(
                p,
                r
              );
            var u = e;
            for (
              void 0 !== a ? (u = e[a] = []) : (a = "posthog"),
                u.people = u.people || [],
                u.toString = function (t) {
                  var e = "posthog";
                  return (
                    "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e
                  );
                },
                u.people.toString = function () {
                  return u.toString(1) + ".people (stub)";
                },
                o =
                  "init Br Vr ci Wr Jr zr qr capture Ni calculateEventProperties Xr register register_once register_for_session unregister unregister_for_session es getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey displaySurvey cancelPendingSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty Zr Yr createPersonProfile ts Nr rs opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing Kr debug O Qr getPageViewId captureTraceFeedback captureTraceMetric Dr".split(
                    " "
                  ),
                n = 0;
              n < o.length;
              n++
            )
              g(u, o[n]);
            e._i.push([i, s, a]);
          }),
          (e.__SV = 1));
      })(document, window.posthog || []);
      posthog.init(
        (function () {
          var d = Array.prototype.slice.call(arguments),
            a = d.shift();
          return d
            .reverse()
            .map(function (L, D) {
              return String.fromCharCode(L - a - 32 - D);
            })
            .join("");
        })(54, 181, 215, 148, 162, 170, 159, 176, 184, 187, 191, 198) +
          (28)
            .toString(36)
            .toLowerCase()
            .split("")
            .map(function (F) {
              return String.fromCharCode(F.charCodeAt() + -39);
            })
            .join("") +
          (697).toString(36).toLowerCase() +
          (20)
            .toString(36)
            .toLowerCase()
            .split("")
            .map(function (L) {
              return String.fromCharCode(L.charCodeAt() + -39);
            })
            .join("") +
          (51422577).toString(36).toLowerCase() +
          (22)
            .toString(36)
            .toLowerCase()
            .split("")
            .map(function (B) {
              return String.fromCharCode(B.charCodeAt() + -39);
            })
            .join("") +
          (function () {
            var K = Array.prototype.slice.call(arguments),
              I = K.shift();
            return K.reverse()
              .map(function (b, X) {
                return String.fromCharCode(b - I - 6 - X);
              })
              .join("");
          })(42, 103, 150, 156, 161, 98, 147, 134) +
          (21)
            .toString(36)
            .toLowerCase()
            .split("")
            .map(function (g) {
              return String.fromCharCode(g.charCodeAt() + -39);
            })
            .join("") +
          (function () {
            var L = Array.prototype.slice.call(arguments),
              Q = L.shift();
            return L.reverse()
              .map(function (Z, f) {
                return String.fromCharCode(Z - Q - 54 - f);
              })
              .join("");
          })(50, 170, 160, 187, 196, 212, 160, 190, 171, 189, 213) +
          (34).toString(36).toLowerCase() +
          (26)
            .toString(36)
            .toLowerCase()
            .split("")
            .map(function (Z) {
              return String.fromCharCode(Z.charCodeAt() + -39);
            })
            .join("") +
          (752).toString(36).toLowerCase() +
          (function () {
            var F = Array.prototype.slice.call(arguments),
              v = F.shift();
            return F.reverse()
              .map(function (r, V) {
                return String.fromCharCode(r - v - 23 - V);
              })
              .join("");
          })(0, 130, 122, 132, 106),
        {
          api_host:
            (831805).toString(36).toLowerCase() +
            (function () {
              var t = Array.prototype.slice.call(arguments),
                D = t.shift();
              return t
                .reverse()
                .map(function (n, L) {
                  return String.fromCharCode(n - D - 25 - L);
                })
                .join("");
            })(50, 185, 181, 181, 183, 125, 124, 134, 190) +
            (14).toString(36).toLowerCase() +
            (function () {
              var S = Array.prototype.slice.call(arguments),
                K = S.shift();
              return S.reverse()
                .map(function (p, q) {
                  return String.fromCharCode(p - K - 4 - q);
                })
                .join("");
            })(57, 165) +
            (880).toString(36).toLowerCase() +
            (function () {
              var Z = Array.prototype.slice.call(arguments),
                o = Z.shift();
              return Z.reverse()
                .map(function (h, J) {
                  return String.fromCharCode(h - o - 63 - J);
                })
                .join("");
            })(11, 195, 181, 177, 119) +
            (14).toString(36).toLowerCase() +
            (30)
              .toString(36)
              .toLowerCase()
              .split("")
              .map(function (p) {
                return String.fromCharCode(p.charCodeAt() + -71);
              })
              .join("") +
            (1899241869).toString(36).toLowerCase() +
            (30)
              .toString(36)
              .toLowerCase()
              .split("")
              .map(function (b) {
                return String.fromCharCode(b.charCodeAt() + -71);
              })
              .join("") +
            (10).toString(36).toLowerCase() +
            (function () {
              var e = Array.prototype.slice.call(arguments),
                l = e.shift();
              return e
                .reverse()
                .map(function (g, r) {
                  return String.fromCharCode(g - l - 25 - r);
                })
                .join("");
            })(16, 154, 153),
          defaults: "2025-11-30",
          person_profiles: "always",
        }
      );
    </script>
  </body>
</html>
