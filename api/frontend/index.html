<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Axiplace | JBlitzar</title>
    <link rel="stylesheet" href="https://jblitzar.github.io/global.css" />
    <link rel=icon href=https://jblitzar.github.io/favicon.png> '
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <style>
      canvas {
        border: 1px solid #ccc;
        cursor: crosshair;
        display: block;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <h1>Thing</h1>
    <br />
    <center>
      <div
        class="container"
        style="
          position: relative;
          display: inline-block;
          width: 100%;
          max-width: 800px;
        "
      >
        <center>
          <img
            id="stream"
            src=""
            alt="Loading stream..."
            style="width: 100%; height: auto; max-width: 800px"
          />
          <br />
          <canvas
            id="canvas"
            style="
              width: 100%;
              height: auto;
              max-width: 720px;
              position: absolute;
              top: 0;
              left: 0;
              cursor: crosshair;
            "
          ></canvas>
        </center>
      </div>
      <div id="modal-overlay"></div>
      <div id="editor-modal">
        <h3>Draw Curve for Cell (<span id="cell-coords"></span>)</h3>
        <canvas id="editor-canvas" width="400" height="400"></canvas>
        <br />
        <button id="submit-curve">Submit</button>
        <button id="cancel-curve">Cancel</button>
      </div>
      <button id="send">Send Command</button>
    </center>

    <script>
      const API_BASE = "https://axiplace.vercel.app";

      async function loadStreamUrl() {
        try {
          const resp = await fetch(`${API_BASE}/stream-url`);
          const data = await resp.json();
          if (data.stream_url) {
            document.getElementById("stream").src = data.stream_url;
          } else {
            console.error("No stream URL available:", data.error);
          }
        } catch (err) {
          console.error("Failed to fetch stream URL:", err);
        }
      }

      loadStreamUrl();

      document.getElementById("send").addEventListener("click", async () => {
        const command = prompt("command: ");
        if (!command) return;

        let resp = await fetch(`${API_BASE}/add_command`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ command }),
        });
        let data = await resp.json();
        console.log(resp.status);
        if (data.status != "success") {
          alert(data.message || data.error);
        } else {
          alert("Command sent successfully!");
        }
      });
    </script>

    <script>
      let GRID_W = 32;
      let GRID_H = 16;
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      cur_width = canvas.clientWidth;
      canvas.width = cur_width;
      canvas.height = (cur_width * GRID_H) / GRID_W;
      CELL_SIZE = canvas.width / GRID_W;

      function Cell(x, y) {
        this.x = x;
        this.y = y;
      }
      Cell.prototype.isInside = function (mx, my) {
        return (
          mx >= this.x * CELL_SIZE &&
          mx < (this.x + 1) * CELL_SIZE &&
          my >= this.y * CELL_SIZE &&
          my < (this.y + 1) * CELL_SIZE
        );
      };
      Cell.prototype.draw = function (ctx) {
        ctx.strokeStyle = "#ccc";
        ctx.strokeRect(
          this.x * CELL_SIZE,
          this.y * CELL_SIZE,
          CELL_SIZE,
          CELL_SIZE
        );
      };
      const grid = [];
      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
          grid.push(new Cell(x, y));
        }
      }
      Cell.redraw = function () {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        grid.forEach((cell) => cell.draw(ctx));
      };

      Cell.redraw();
      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        for (const cell of grid) {
          if (cell.isInside(mx, my)) {
            openEditorModal(cell);
            Cell.redraw();
            break;
          }
        }
      });

      function BezierPoint(x, y, movingCallback = null, edgesOnly = false) {
        this.x = x;
        this.y = y;
        this._inst = new fabric.Circle({
          radius: 5,
          fill: "red",
          left: x,
          top: y,
          hasControls: false,
          hasBorders: false,
          selectable: true,
          lockRotation: true,
          lockScalingX: true,
          lockScalingY: true,
        });
        this.edgesOnly = edgesOnly;

        function _clamp(value, min, max) {
          return Math.min(Math.max(value, min), max);
        }

        this._inst.on("moving", (e) => {
          const canvasWidth = this._inst.canvas.width;
          const canvasHeight = this._inst.canvas.height;
          const radius = this._inst.radius;

          this._inst.left = _clamp(
            this._inst.left,
            radius,
            canvasWidth - radius
          );
          this._inst.top = _clamp(
            this._inst.top,
            radius,
            canvasHeight - radius
          );

          if (this.edgesOnly) {
            let xPass =
              this._inst.left > canvasWidth - radius ||
              this._inst.left < radius;
            let yPass =
              this._inst.top > canvasHeight - radius || this._inst.top < radius;

            // both pass == corner, one pass == edge
            // no pass == violation! Go to closest edge
            if (!xPass && !yPass) {
              // ugh violates DRY but whatever
              let dl = this._inst.left - radius;
              let dr = canvasWidth - radius - this._inst.left;
              let dt = this._inst.top - radius;
              let db = canvasHeight - radius - this._inst.top;
              let minDist = Math.min(dl, dr, dt, db);
              if (minDist === dl) {
                this._inst.left = radius;
              } else if (minDist === dr) {
                this._inst.left = canvasWidth - radius;
              } else if (minDist === dt) {
                this._inst.top = radius;
              } else if (minDist === db) {
                this._inst.top = canvasHeight - radius;
              }
            }
          }

          this.x = this._inst.left;
          this.y = this._inst.top;
          //   console.log(this._inst);
          if (movingCallback) movingCallback();
        });
      }
      function openEditorModal(cell) {
        const modal = document.getElementById("editor-modal");
        const mcanvas = new fabric.Canvas("editor-canvas");

        document.getElementById(
          "cell-coords"
        ).innerText = `${cell.x}, ${cell.y}`;
        modal.style.display = "block";
        function moved() {
          console.log(bezierPath);
          const pathData = [
            ["M", p0._inst.left, p0._inst.top],
            [
              "C",
              p1._inst.left,
              p1._inst.top,
              p2._inst.left,
              p2._inst.top,
              p3._inst.left,
              p3._inst.top,
            ],
          ];

          bezierPath.set({ path: pathData });
          console.log(bezierPath);
          mcanvas.renderAll();
        }
        const p0 = new BezierPoint(50, 390, moved, true);
        const p1 = new BezierPoint(150, 50, moved);
        const p2 = new BezierPoint(250, 50, moved);
        const p3 = new BezierPoint(350, 390, moved, true);

        mcanvas.add(p0._inst, p1._inst, p2._inst, p3._inst);
        let bezierPath = new fabric.Path(
          `M ${p0._inst.left} ${p0._inst.top} C ${p1._inst.left} ${p1._inst.top}, ${p2._inst.left} ${p2._inst.top}, ${p3._inst.left} ${p3._inst.top}`,
          {
            fill: "",
            stroke: "black",
            strokeWidth: 2,
            selectable: false,
            objectCaching: false,
          }
        );
        mcanvas.add(bezierPath);
      }
    </script>
  </body>
</html>
