<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Axiplace | JBlitzar</title>
    <link rel="stylesheet" href="https://jblitzar.github.io/global.css" />
    <link rel=icon href=https://jblitzar.github.io/favicon.png> '
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <style>
      canvas {
        border: 1px solid #ccc;
        cursor: crosshair;
        display: block;
        margin: 0 auto;
      }

      #stream-container {
        position: relative;
        display: inline-block;
        width: 100%;
        max-width: 800px;
      }

      #stream {
        display: block;
        width: 100%;
        height: auto;
      }

      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: all;
        cursor: crosshair;
        z-index: 300;
      }
    </style>
  </head>
  <body>
    <h1>Thing</h1>
    <br />
    <center>
      <div id="stream-container">
        <img id="stream" src="" alt="Loading stream..." />
        <canvas id="canvas"></canvas>
      </div>

      <div id="editor-modal" style="display: none">
        <h3>Draw Curve for Cell (<span id="cell-coords"></span>)</h3>
        <canvas id="editor-canvas" width="400" height="400"></canvas>
        <br />
        <button id="submit-curve">Submit</button>
      </div>
    </center>

    <script>
      const API_BASE = "https://axiplace.vercel.app";

      async function loadStreamUrl() {
        try {
          const resp = await fetch(`${API_BASE}/stream-url`);
          const data = await resp.json();
          if (data.stream_url) {
            document.getElementById("stream").src = data.stream_url;
            resizeCanvas();
          } else {
            console.error("No stream URL available:", data.error);
          }
        } catch (err) {
          console.error("Failed to fetch stream URL:", err);
        }
      }

      loadStreamUrl();
    </script>

    <script>
      let GRID_W = 24;
      let GRID_H = 18;
      const streamContainer = document.getElementById("stream-container");
      const stream = document.getElementById("stream");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      cur_width = canvas.clientWidth;
      canvas.width = cur_width;
      canvas.height = (cur_width * GRID_H) / GRID_W;
      CELL_SIZE = canvas.width / GRID_W;

      function Cell(x, y) {
        this.x = x;
        this.y = y;
      }
      window._redrawCells = function () {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (const cell of grid) {
          cell.draw(ctx);
        }
      };
      Cell.prototype.isInside = function (mx, my) {
        return (
          mx >= this.x * CELL_SIZE &&
          mx < (this.x + 1) * CELL_SIZE &&
          my >= this.y * CELL_SIZE &&
          my < (this.y + 1) * CELL_SIZE
        );
      };
      Cell.prototype.draw = function (ctx) {
        console.log("drawing cell", this.x, this.y, CELL_SIZE);
        ctx.strokeStyle = "#ccc";
        ctx.strokeRect(
          this.x * CELL_SIZE,
          this.y * CELL_SIZE,
          CELL_SIZE,
          CELL_SIZE
        );
      };
      const grid = [];
      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
          grid.push(new Cell(x, y));
        }
      }
      window._cell = grid[0];

      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        for (const cell of grid) {
          if (cell.isInside(mx, my)) {
            openEditorModal(cell);
            window._redrawCells();
            break;
          }
        }
      });

      function BezierPoint(x, y, movingCallback = null, edgesOnly = false) {
        this.x = x;
        this.y = y;
        this._inst = new fabric.Circle({
          radius: 5,
          fill: "red",
          left: x,
          top: y,
          hasControls: false,
          hasBorders: false,
          selectable: true,
          lockRotation: true,
          lockScalingX: true,
          lockScalingY: true,
        });
        this.edgesOnly = edgesOnly;

        function _clamp(value, min, max) {
          return Math.min(Math.max(value, min), max);
        }

        this._inst.on("moving", (e) => {
          const canvasWidth = this._inst.canvas.width;
          const canvasHeight = this._inst.canvas.height;
          const radius = this._inst.radius;

          this._inst.left = _clamp(
            this._inst.left,
            radius,
            canvasWidth - radius
          );
          this._inst.top = _clamp(
            this._inst.top,
            radius,
            canvasHeight - radius
          );

          if (this.edgesOnly) {
            let xPass =
              this._inst.left > canvasWidth - radius ||
              this._inst.left < radius;
            let yPass =
              this._inst.top > canvasHeight - radius || this._inst.top < radius;

            // both pass == corner, one pass == edge
            // no pass == violation! Go to closest edge
            if (!xPass && !yPass) {
              // ugh violates DRY but whatever
              let dl = this._inst.left - radius;
              let dr = canvasWidth - radius - this._inst.left;
              let dt = this._inst.top - radius;
              let db = canvasHeight - radius - this._inst.top;
              let minDist = Math.min(dl, dr, dt, db);
              if (minDist === dl) {
                this._inst.left = radius;
              } else if (minDist === dr) {
                this._inst.left = canvasWidth - radius;
              } else if (minDist === dt) {
                this._inst.top = radius;
              } else if (minDist === db) {
                this._inst.top = canvasHeight - radius;
              }
            }
          }

          this.x = this._inst.left;
          this.y = this._inst.top;
          //   console.log(this._inst);
          if (movingCallback) movingCallback();
        });
      }
      document.getElementById("submit-curve").addEventListener("click", () => {
        fetch(`${API_BASE}/add_command`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ command: curCurve }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.status === "success") {
              alert("Curve submitted successfully!");
              document.getElementById("editor-modal").style.display = "none";
            } else {
              alert(data.message || data.error || "Failed to submit curve");
            }
          })
          .catch((err) => {
            console.error("Error submitting curve:", err);
            alert("Failed to submit curve");
          });
      });
      let curCurve = null;
      function moved() {
        console.log(bezierPath);
        const pathData = [
          ["M", p0._inst.left, p0._inst.top],
          [
            "C",
            p1._inst.left,
            p1._inst.top,
            p2._inst.left,
            p2._inst.top,
            p3._inst.left,
            p3._inst.top,
          ],
        ];

        bezierPath.set({ path: pathData });
        console.log(bezierPath);
        mcanvas.renderAll();
        curCurve = {
          cell: [window._cell.x, window._cell.y],
          path: [
            [p0.x / CELL_SIZE, p0.y / CELL_SIZE],
            [p1.x / CELL_SIZE, p1.y / CELL_SIZE],
            [p2.x / CELL_SIZE, p2.y / CELL_SIZE],
            [p3.x / CELL_SIZE, p3.y / CELL_SIZE],
          ],
        };
      }
      const mcanvas = new fabric.Canvas("editor-canvas");
      const p0 = new BezierPoint(50, 390, moved, true);
      const p1 = new BezierPoint(150, 50, moved);
      const p2 = new BezierPoint(250, 50, moved);
      const p3 = new BezierPoint(350, 390, moved, true);
      mcanvas.add(p0._inst, p1._inst, p2._inst, p3._inst);
      let bezierPath = new fabric.Path(
        `M ${p0._inst.left} ${p0._inst.top} C ${p1._inst.left} ${p1._inst.top}, ${p2._inst.left} ${p2._inst.top}, ${p3._inst.left} ${p3._inst.top}`,
        {
          fill: "",
          stroke: "black",
          strokeWidth: 2,
          selectable: false,
          objectCaching: false,
        }
      );
      curCurve = {
        cell: [window._cell.x, window._cell.y],
        path: [
          [p0.x / CELL_SIZE, p0.y / CELL_SIZE],
          [p1.x / CELL_SIZE, p1.y / CELL_SIZE],
          [p2.x / CELL_SIZE, p2.y / CELL_SIZE],
          [p3.x / CELL_SIZE, p3.y / CELL_SIZE],
        ],
      };
      mcanvas.add(bezierPath);
      function openEditorModal(cell) {
        window._cell = cell;
        const modal = document.getElementById("editor-modal");

        document.getElementById(
          "cell-coords"
        ).innerText = `${cell.x}, ${cell.y}`;
        modal.style.display = "block";
        modal.scrollIntoView({ behavior: "smooth", block: "center" });
      }

      function resizeCanvas() {
        const rect = stream.getBoundingClientRect();

        canvas.width = rect.width;
        canvas.height = rect.height;

        CELL_SIZE = canvas.width / GRID_W;

        window._redrawCells();
      }

      stream.addEventListener("load", resizeCanvas);
      window.addEventListener("resize", resizeCanvas);

      resizeCanvas();
    </script>
  </body>
</html>
